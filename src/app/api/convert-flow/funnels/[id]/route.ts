import { NextRequest, NextResponse } from 'next/server'
import { supabase } from '@/lib/supabase'

export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
  try {
    const funnelId = params.id

    // Get funnel with analytics data
    const { data: funnel, error } = await supabase
      .from('convert_flow_funnels')
      .select(`
        *,
        convert_flow_funnel_analytics!convert_flow_funnel_analytics_funnel_id_fkey(
          date,
          unique_visitors,
          page_views,
          opt_ins,
          conversions,
          revenue,
          opt_in_rate,
          conversion_rate,
          bounce_rate,
          avg_session_duration
        )
      `)
      .eq('id', funnelId)
      .single()

    if (error) {
      if (error.code === 'PGRST116') {
        return NextResponse.json({ error: 'Funnel not found' }, { status: 404 })
      }
      console.error('[CONVERT-FLOW] Error fetching funnel:', error)
      return NextResponse.json({ error: 'Failed to fetch funnel' }, { status: 500 })
    }

    // Get leads generated by this funnel
    const { data: funnelLeads } = await supabase
      .from('convert_flow_leads')
      .select('id, first_name, last_name, email, company, lead_score, stage, created_at')
      .eq('lead_source', `funnel_${funnelId}`)
      .order('created_at', { ascending: false })
      .limit(50)

    // Calculate funnel health metrics
    const healthMetrics = calculateFunnelHealth(funnel, funnel.convert_flow_funnel_analytics)

    return NextResponse.json({
      funnel,
      leads: funnelLeads || [],
      healthMetrics,
      analytics: {
        recent: funnel.convert_flow_funnel_analytics?.slice(-30) || [],
        summary: summarizeAnalytics(funnel.convert_flow_funnel_analytics || [])
      }
    })

  } catch (error) {
    console.error('[CONVERT-FLOW] Unexpected error fetching funnel:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  try {
    const funnelId = params.id
    const updateData = await request.json()

    // Remove fields that shouldn't be updated directly
    const { id, created_at, total_visitors, total_conversions, ...safeUpdateData } = updateData

    // Add updated timestamp
    safeUpdateData.updated_at = new Date().toISOString()

    // If publishing for the first time, set published_at
    if (safeUpdateData.is_published && updateData.status === 'active') {
      safeUpdateData.published_at = new Date().toISOString()
    }

    // Update funnel
    const { data: updatedFunnel, error } = await supabase
      .from('convert_flow_funnels')
      .update(safeUpdateData)
      .eq('id', funnelId)
      .select()
      .single()

    if (error) {
      if (error.code === 'PGRST116') {
        return NextResponse.json({ error: 'Funnel not found' }, { status: 404 })
      }
      console.error('[CONVERT-FLOW] Error updating funnel:', error)
      return NextResponse.json({ error: 'Failed to update funnel' }, { status: 500 })
    }

    // If funnel was just published, trigger initial automation setup
    if (safeUpdateData.is_published && safeUpdateData.status === 'active') {
      await initializeFunnelAutomation(funnelId, updatedFunnel)
    }

    return NextResponse.json({
      funnel: updatedFunnel,
      message: 'Funnel updated successfully'
    })

  } catch (error) {
    console.error('[CONVERT-FLOW] Unexpected error updating funnel:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
  try {
    const funnelId = params.id

    // Check if funnel has active campaigns or leads
    const { data: activeCampaigns } = await supabase
      .from('convert_flow_email_campaigns')
      .select('id')
      .eq('funnel_id', funnelId)
      .eq('is_active', true)

    const { data: funnelLeads } = await supabase
      .from('convert_flow_leads')
      .select('id')
      .eq('lead_source', `funnel_${funnelId}`)
      .limit(1)

    if (activeCampaigns?.length || funnelLeads?.length) {
      return NextResponse.json({ 
        error: 'Cannot delete funnel with active campaigns or existing leads. Archive instead.' 
      }, { status: 400 })
    }

    // Delete funnel (cascade will handle analytics)
    const { error } = await supabase
      .from('convert_flow_funnels')
      .delete()
      .eq('id', funnelId)

    if (error) {
      console.error('[CONVERT-FLOW] Error deleting funnel:', error)
      return NextResponse.json({ error: 'Failed to delete funnel' }, { status: 500 })
    }

    return NextResponse.json({ message: 'Funnel deleted successfully' })

  } catch (error) {
    console.error('[CONVERT-FLOW] Unexpected error deleting funnel:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// Calculate funnel health score and insights
function calculateFunnelHealth(funnel: any, analytics: any[]) {
  if (!analytics?.length) {
    return {
      score: 0,
      status: 'insufficient_data',
      insights: ['Not enough data to calculate health metrics'],
      recommendations: ['Let funnel run for at least 7 days to gather meaningful data']
    }
  }

  const recent30Days = analytics.slice(-30)
  let healthScore = 100
  const insights = []
  const recommendations = []

  // Traffic analysis
  const avgVisitors = recent30Days.reduce((sum, day) => sum + (day.unique_visitors || 0), 0) / recent30Days.length
  const avgConversionRate = recent30Days.reduce((sum, day) => sum + (day.conversion_rate || 0), 0) / recent30Days.length
  const avgBounceRate = recent30Days.reduce((sum, day) => sum + (day.bounce_rate || 0), 0) / recent30Days.length

  // Traffic health (25 points)
  if (avgVisitors < 10) {
    healthScore -= 20
    insights.push('Low traffic volume detected')
    recommendations.push('Increase marketing efforts to drive more traffic')
  } else if (avgVisitors > 100) {
    insights.push('Strong traffic volume')
  }

  // Conversion health (35 points)
  const benchmarkConversion = getBenchmarkConversion(funnel.funnel_type)
  if (avgConversionRate < benchmarkConversion * 0.5) {
    healthScore -= 25
    insights.push(`Conversion rate (${avgConversionRate.toFixed(1)}%) is below industry benchmark`)
    recommendations.push('Optimize landing page copy and call-to-action placement')
  } else if (avgConversionRate > benchmarkConversion * 1.2) {
    insights.push(`Excellent conversion rate (${avgConversionRate.toFixed(1)}%) above industry benchmark`)
  }

  // Engagement health (25 points)
  if (avgBounceRate > 70) {
    healthScore -= 15
    insights.push('High bounce rate indicates poor page relevance')
    recommendations.push('Review page load speed and message-market fit')
  } else if (avgBounceRate < 40) {
    insights.push('Good visitor engagement with low bounce rate')
  }

  // Revenue performance (15 points)
  const totalRevenue = recent30Days.reduce((sum, day) => sum + (day.revenue || 0), 0)
  if (totalRevenue === 0 && funnel.funnel_type !== 'lead_magnet') {
    healthScore -= 10
    insights.push('No revenue generated from funnel')
    recommendations.push('Review pricing strategy and sales process')
  }

  // Trend analysis
  const firstHalf = recent30Days.slice(0, 15)
  const secondHalf = recent30Days.slice(15)
  
  const firstHalfAvgConversion = firstHalf.reduce((sum, day) => sum + (day.conversion_rate || 0), 0) / firstHalf.length
  const secondHalfAvgConversion = secondHalf.reduce((sum, day) => sum + (day.conversion_rate || 0), 0) / secondHalf.length

  if (secondHalfAvgConversion > firstHalfAvgConversion * 1.1) {
    insights.push('Conversion rate trending upward - funnel is improving')
  } else if (secondHalfAvgConversion < firstHalfAvgConversion * 0.9) {
    insights.push('Conversion rate declining - needs attention')
    recommendations.push('Analyze recent changes and consider A/B testing')
  }

  const status = healthScore >= 80 ? 'excellent' : 
                 healthScore >= 60 ? 'good' : 
                 healthScore >= 40 ? 'needs_attention' : 'critical'

  return {
    score: Math.max(0, Math.min(100, Math.round(healthScore))),
    status,
    insights,
    recommendations,
    metrics: {
      avgDailyVisitors: Math.round(avgVisitors),
      avgConversionRate: Math.round(avgConversionRate * 100) / 100,
      avgBounceRate: Math.round(avgBounceRate * 100) / 100,
      total30DayRevenue: Math.round(totalRevenue * 100) / 100
    }
  }
}

// Get industry benchmark conversion rates
function getBenchmarkConversion(funnelType: string): number {
  const benchmarks: Record<string, number> = {
    'lead_magnet': 15, // 15% average
    'webinar': 25,     // 25% average
    'consultation': 5,  // 5% average (higher intent)
    'product_demo': 8,  // 8% average
    'free_trial': 12   // 12% average
  }
  return benchmarks[funnelType] || 10
}

// Summarize analytics data
function summarizeAnalytics(analytics: any[]) {
  if (!analytics.length) {
    return {
      totalVisitors: 0,
      totalConversions: 0,
      totalRevenue: 0,
      avgConversionRate: 0,
      avgBounceRate: 0
    }
  }

  const totals = analytics.reduce((acc, day) => ({
    visitors: acc.visitors + (day.unique_visitors || 0),
    conversions: acc.conversions + (day.conversions || 0),
    revenue: acc.revenue + (day.revenue || 0),
    bounceRate: acc.bounceRate + (day.bounce_rate || 0),
    conversionRate: acc.conversionRate + (day.conversion_rate || 0)
  }), { visitors: 0, conversions: 0, revenue: 0, bounceRate: 0, conversionRate: 0 })

  return {
    totalVisitors: totals.visitors,
    totalConversions: totals.conversions,
    totalRevenue: Math.round(totals.revenue * 100) / 100,
    avgConversionRate: Math.round((totals.conversionRate / analytics.length) * 100) / 100,
    avgBounceRate: Math.round((totals.bounceRate / analytics.length) * 100) / 100
  }
}

// Initialize automation when funnel is published
async function initializeFunnelAutomation(funnelId: string, funnel: any) {
  try {
    // Set up tracking pixels and integrations based on funnel configuration
    const automationRules = funnel.automation_rules || {}
    
    // Create default email sequences if they don't exist
    if (automationRules.triggers?.length > 0) {
      for (const trigger of automationRules.triggers) {
        for (const action of trigger.actions || []) {
          if (action.type === 'add_to_sequence' && action.sequence) {
            await ensureEmailSequenceExists(action.sequence, funnel.funnel_type)
          }
        }
      }
    }

    console.log(`[CONVERT-FLOW] Automation initialized for funnel ${funnelId}`)
  } catch (error) {
    console.error(`[CONVERT-FLOW] Failed to initialize automation for funnel ${funnelId}:`, error)
  }
}

// Ensure email sequence exists for automation
async function ensureEmailSequenceExists(sequenceName: string, funnelType: string) {
  try {
    // Check if sequence already exists
    const { data: existingCampaign } = await supabase
      .from('convert_flow_email_campaigns')
      .select('id')
      .eq('name', sequenceName)
      .single()

    if (!existingCampaign) {
      // Create default email sequence based on funnel type
      const sequenceData = getDefaultEmailSequence(sequenceName, funnelType)
      
      await supabase
        .from('convert_flow_email_campaigns')
        .insert(sequenceData)
    }
  } catch (error) {
    console.error(`[CONVERT-FLOW] Failed to create email sequence ${sequenceName}:`, error)
  }
}

// Get default email sequence configuration
function getDefaultEmailSequence(sequenceName: string, funnelType: string) {
  const sequences: Record<string, any> = {
    'nurture_new_leads': {
      name: sequenceName,
      campaign_type: 'nurture',
      email_sequence: [
        {
          delay: 0,
          subject: 'Welcome! Here\'s your {resource_name}',
          template: 'lead_magnet_delivery',
          content: 'Thank you for downloading our {resource_name}...'
        },
        {
          delay: 24 * 60 * 60, // 1 day
          subject: 'Did you get a chance to review {resource_name}?',
          template: 'follow_up_engagement',
          content: 'I wanted to follow up on the {resource_name} you downloaded...'
        },
        {
          delay: 3 * 24 * 60 * 60, // 3 days
          subject: 'Case study: How {client_name} got {result}',
          template: 'case_study_nurture',
          content: 'I thought you\'d be interested in this success story...'
        }
      ],
      trigger_conditions: {
        event: 'form_submit',
        funnel_type: funnelType
      },
      status: 'draft',
      is_active: false
    }
  }

  return sequences[sequenceName] || sequences['nurture_new_leads']
}